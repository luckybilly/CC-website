## 组件化核心引擎（路由 VS 总线）


### 相同点

路由和组件总线都需要将分布在不同组件module中的某些类按照一定规则生成映射表（数据结构通常是Map，Key为一个字符串，Value为类或对象）

然后在需要用到的时候从映射表中根据字符串从映射表中取出类或对象

### 不同点

#### 1. 路由方案（如：[ARouter](https://github.com/alibaba/ARouter)等）

1.1 **路由的本质是类的查找**

其工作原理类似于仓库管理员：大家先把类全部放到仓库中，有人需要的时候，仓库管理员就根据所提供的字符串找出存放在仓库中的类

查找的类主要分为3种：Activity子类、Fragment子类和自定义接口实现类

- Activity子类： 路由库提供startActivity(或startActivityForResult)的封装，并根据字符串从映射表中获取对应的Activity类(XxxActivity.class)，跳转到该Activity页面
- Fragment子类：路由库根据字符串从映射表中获取对应的Fragment类(XxxFragment.class)并创建一个对象返回给调用方
- 自定义接口实现类：路由库根据字符串（注解的字符串或者接口类名字符串）从映射表中获取对应接口的实现类（XxxInterfaceImpl.class)，并创建一个对象返回给调用方

1.2 路由这种一对一的类映射关系理解起来比较容易，特别是页面跳转，使用起来也很方便

1.3 组件之间的服务调用时，调用方需要持有接口类，需要将接口类定义下沉到base层，向接口编程，遵循依赖倒置原则

1.4 由于路由本质是类查找，所以需要通信的组件必须要打包在同一个app内部才能获取到。

#### 2. 组件总线方案（如：[CC](https://github.com/luckybilly/CC)）

2.1 **组件总线的本质是转发调用请求**

其工作原理类似于电话接线员（中介者模式）：组件总线负责收集所有组件类并形成映射表（Key为字符串，Value为组件类的对象）。调用组件时，总线根据字符串找到对应的组件类并将调用信息转发给该组件类，组件执行完成后再通过组件总线将结果返回给调用方

2.2 组件总线只负责通信，即转发调用请求和返回执行结果。

2.3 不需要下沉接口，面向通信协议编程（类似于app客户端调用服务器端接口的通信协议）

2.4 由于组件总线的本质是转发调用请求，可以通过跨进程通信方式将调用请求转发给其它app，从而实现跨app进行组件调用。

    Tips: 跨进程通信的方式有很多种，例如：
    BroadcastReceiver、Socket、FileObserver、MemoryFile、UrlScheme、ContentProvider、AIDL、Messenger及Binder等等

支持跨app的组件调用后，单组件作为app运行时，可以与主app进行通信，调用主app中的所有组件，无需与其他组件一起打包运行，所有的组件都是平行的，没有依赖关系，带来的好处有：

- 从框架层面避免了组件之间的依赖，做到完全的代码隔离。
- 组件独立运行时编译速度更快
- 老项目改造时，从第一个组件开始就可以独立运行，而不会因为需要调用到组件外的功能而必须跟主工程一起打包运行调试

